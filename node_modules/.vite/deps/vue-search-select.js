import "./chunk-SCIU4NBZ.js";
import {
  Fragment,
  createBaseVNode,
  createCommentVNode,
  createElementBlock,
  createTextVNode,
  h,
  normalizeClass,
  normalizeStyle,
  openBlock,
  renderList,
  toDisplayString,
  vModelText,
  withDirectives,
  withKeys,
  withModifiers
} from "./chunk-3YKYIJLK.js";
import "./chunk-OL3AADLO.js";

// node_modules/vue-search-select/dist/VueSearchSelect.js
var l = {
  openOptions(e) {
    e.$refs.input.focus(), e.showMenu = true, e.mousedownState = false;
  },
  blurInput(e) {
    e.mousedownState || (e.searchText = "", e.closeOptions()), e.$emit("blur");
  },
  closeOptions(e) {
    e.$refs.input.blur(), e.showMenu = false;
  },
  prevItem(e) {
    const t = e.pointer - 1, n = e.$el.offsetHeight * t;
    t >= 0 && (e.pointer = t), e.$refs.menu.scrollTop = n;
  },
  nextItem(e) {
    const t = e.pointer + 1, n = e.$el.offsetHeight * t;
    t <= e.filteredOptions.length - 1 && (e.pointer = t);
    const d = e.$refs.menu.offsetHeight, r = Math.ceil((e.$refs.menu.scrollTop + e.$el.offsetHeight) / d), s = Math.ceil(n / d);
    r !== s && (e.$refs.menu.scrollTop = (s - 1) * e.$refs.menu.offsetHeight);
  },
  enterItem(e) {
    const t = e.filteredOptions[e.pointer], n = t.disabled;
    t && !n && e.selectItem(t);
  },
  pointerSet(e, t) {
    e.pointer = t;
  },
  pointerAdjust(e) {
    e.pointer >= e.filteredOptions.length - 1 && (e.pointer = e.filteredOptions.length ? e.filteredOptions.length - 1 : 0);
  },
  mousedownItem(e) {
    e.mousedownState = true;
  }
};
function C(e) {
  return new RegExp(e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), "i");
}
var b = {
  props: {
    id: {
      default: null
    },
    name: {
      type: String,
      default: ""
    },
    isError: {
      type: Boolean,
      default: false
    },
    customAttr: {
      type: Function,
      default: () => ""
    },
    isDisabled: {
      type: Boolean,
      default: false
    },
    placeholder: {
      type: String,
      default: ""
    },
    filterPredicate: {
      type: Function,
      default: (e, t) => e.match(C(t))
    }
  }
};
var w = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [d, r] of t)
    n[d] = r;
  return n;
};
var E = {
  name: "ModelSelect",
  mixins: [b],
  emits: ["blur", "searchchange", "update:modelValue"],
  props: {
    modelValue: {
      type: [String, Number, Object, Boolean]
    },
    customAttr: {
      type: Function,
      default: () => ""
    },
    options: {
      type: Array
    }
  },
  data() {
    return {
      showMenu: false,
      searchText: "",
      mousedownState: false,
      pointer: -1
    };
  },
  watch: {
    value(e) {
      this.pointer = this.filteredOptions.findIndex((t) => t.value === this.optionValue(e));
    },
    filteredOptions() {
      this.pointerAdjust();
    },
    searchText() {
      this.$emit("searchchange", this.searchText);
    }
  },
  computed: {
    searchTextCustomAttr() {
      return this.selectedOption && this.selectedOption.value ? this.customAttr(this.selectedOption) : "";
    },
    inputText() {
      if (this.searchText)
        return "";
      {
        let e = this.placeholder;
        return this.selectedOption && (e = this.selectedOption.text), e;
      }
    },
    customAttrs() {
      try {
        if (Array.isArray(this.options))
          return this.options.map((e) => this.customAttr(e));
      } catch {
      }
      return [];
    },
    textClass() {
      return !this.selectedOption && this.placeholder ? "default" : "";
    },
    menuClass() {
      return {
        visible: this.showMenu,
        hidden: !this.showMenu
      };
    },
    menuStyle() {
      return {
        display: this.showMenu ? "block" : "none"
      };
    },
    filteredOptions() {
      return this.searchText ? this.options.filter((e) => {
        try {
          return this.filterPredicate(e.text, this.searchText);
        } catch {
          return true;
        }
      }) : this.options;
    },
    selectedOption() {
      return this.options.find((e) => e.value === this.optionValue(this.modelValue));
    }
  },
  methods: {
    deleteTextOrItem() {
      !this.searchText && this.modelValue && (this.selectItem({}), this.openOptions());
    },
    openOptions() {
      l.openOptions(this);
    },
    blurInput() {
      l.blurInput(this);
    },
    closeOptions() {
      l.closeOptions(this);
    },
    prevItem() {
      l.prevItem(this);
    },
    nextItem() {
      l.nextItem(this);
    },
    enterItem() {
      l.enterItem(this);
    },
    pointerSet(e) {
      l.pointerSet(this, e);
    },
    pointerAdjust() {
      l.pointerAdjust(this);
    },
    mousedownItem() {
      l.mousedownItem(this);
    },
    selectItem(e) {
      this.searchText = "", this.closeOptions(), typeof this.modelValue == "object" && this.modelValue ? this.$emit("update:modelValue", e) : (this.$emit("update:modelValue", e.value), e.value !== void 0 && e.value === e.text && (this.searchText = e.value));
    },
    optionValue(e) {
      return typeof e == "object" && e !== null ? e.value : e;
    }
  }
};
var k = createBaseVNode("i", { class: "dropdown icon" }, null, -1);
var D = ["disabled", "tabindex", "id", "name", "value"];
var j = ["data-vss-custom-attr"];
var R = ["data-vss-custom-attr", "onClick", "onMouseenter"];
function F(e, t, n, d, r, s) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["ui fluid search selection dropdown", { "active visible": r.showMenu, error: e.isError, disabled: e.isDisabled }]),
    onClick: t[11] || (t[11] = (...i) => s.openOptions && s.openOptions(...i)),
    onFocus: t[12] || (t[12] = (...i) => s.openOptions && s.openOptions(...i))
  }, [
    k,
    createBaseVNode("input", {
      class: "search",
      autocomplete: "off",
      disabled: e.isDisabled,
      tabindex: e.isDisabled ? -1 : 0,
      id: e.id,
      name: e.name,
      value: r.searchText,
      onInput: t[0] || (t[0] = (i) => r.searchText = i.target.value),
      ref: "input",
      onFocus: t[1] || (t[1] = withModifiers((...i) => s.openOptions && s.openOptions(...i), ["prevent"])),
      onKeyup: [
        t[2] || (t[2] = withKeys((...i) => s.closeOptions && s.closeOptions(...i), ["esc"])),
        t[7] || (t[7] = withKeys(withModifiers((...i) => s.enterItem && s.enterItem(...i), ["prevent"]), ["enter"]))
      ],
      onBlur: t[3] || (t[3] = (...i) => s.blurInput && s.blurInput(...i)),
      onKeydown: [
        t[4] || (t[4] = withKeys((...i) => s.prevItem && s.prevItem(...i), ["up"])),
        t[5] || (t[5] = withKeys((...i) => s.nextItem && s.nextItem(...i), ["down"])),
        t[6] || (t[6] = withKeys(withModifiers(() => {
        }, ["prevent"]), ["enter"])),
        t[8] || (t[8] = withKeys((...i) => s.deleteTextOrItem && s.deleteTextOrItem(...i), ["delete"]))
      ]
    }, null, 40, D),
    createBaseVNode("div", {
      class: normalizeClass(["text", s.textClass]),
      "data-vss-custom-attr": s.searchTextCustomAttr
    }, toDisplayString(s.inputText), 11, j),
    createBaseVNode("div", {
      class: normalizeClass(["menu", s.menuClass]),
      ref: "menu",
      onMousedown: t[10] || (t[10] = withModifiers(() => {
      }, ["prevent"])),
      style: normalizeStyle(s.menuStyle),
      tabindex: "-1"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(s.filteredOptions, (i, o) => (openBlock(), createElementBlock("div", {
        key: o,
        class: normalizeClass(["item", { selected: i.selected || r.pointer === o, disabled: i.disabled }]),
        "data-vss-custom-attr": s.customAttrs[o] ? s.customAttrs[o] : "",
        onClick: withModifiers((h2) => s.selectItem(i), ["stop"]),
        onMousedown: t[9] || (t[9] = (...h2) => s.mousedownItem && s.mousedownItem(...h2)),
        onMouseenter: (h2) => s.pointerSet(o)
      }, toDisplayString(i.text), 43, R))), 128))
    ], 38)
  ], 34);
}
var y = w(E, [["render", F]]);
var W = {
  name: "ModelListSelect",
  mixins: [b],
  emits: ["blur", "searchchange", "update:modelValue"],
  render: function() {
    return h(y, {
      id: this.id,
      name: this.name,
      options: this.options,
      modelValue: this.innerValue,
      isError: this.isError,
      isDisabled: this.isDisabled,
      placeholder: this.placeholder,
      filterPredicate: this.filterPredicate,
      "onUpdate:modelValue": this.onInput,
      onSearchchange: (e) => this.$emit("searchchange", e)
    });
  },
  props: {
    modelValue: {
      type: [String, Number, Object, Boolean]
    },
    list: {
      type: Array
    },
    optionValue: {
      type: String
    },
    optionText: {
      type: String
    },
    customText: {
      type: Function
    },
    optionDisabled: {
      type: String
    }
  },
  computed: {
    options() {
      return this.list.map((e) => ({ value: e[this.optionValue], text: this.buildText(e), disabled: !!e[this.optionDisabled] }));
    },
    innerValue() {
      return this.modelValue ? typeof this.modelValue == "object" ? this.modelValue ? {
        value: this.modelValue[this.optionValue],
        text: this.buildText(this.modelValue),
        disabled: !!this.modelValue[this.optionDisabled]
      } : { value: "", text: "", disabled: false } : this.modelValue : this.modelValue;
    }
  },
  methods: {
    buildText(e) {
      return e[this.optionValue] !== void 0 ? this.customText ? this.customText(e) : e[this.optionText] : "";
    },
    onInput(e) {
      if (e === void 0)
        return this.$emit("update:modelValue", "");
      if (Object.keys(e).length === 0 && e.constructor === Object)
        this.$emit("update:modelValue", e);
      else if (typeof e == "object") {
        const t = this.list.find((n) => n[this.optionValue] === e.value);
        this.$emit("update:modelValue", t);
      } else
        this.$emit("update:modelValue", e);
    }
  },
  components: {
    ModelSelect: y
  }
};
var B = {
  name: "MultiSelect",
  mixins: [b],
  emits: ["blur", "searchchange", "select"],
  props: {
    customAttr: {
      type: Function,
      default: () => ""
    },
    options: {
      type: Array
    },
    selectedOptions: {
      type: Array
    },
    cleanSearch: {
      type: Boolean,
      default: true
    },
    hideSelectedOptions: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      showMenu: false,
      searchText: "",
      mousedownState: false,
      pointer: -1
    };
  },
  watch: {
    selectedOptions() {
      this.pointer = -1;
    },
    filteredOptions() {
      this.pointerAdjust();
    },
    searchText() {
      this.$emit("searchchange", this.searchText);
    }
  },
  computed: {
    inputText() {
      return this.searchText ? "" : this.placeholder;
    },
    textClass() {
      return this.placeholder ? "default" : "";
    },
    inputWidth() {
      return {
        width: (this.searchText.length + 1) * 8 + 20 + "px"
      };
    },
    menuClass() {
      return {
        visible: this.showMenu,
        hidden: !this.showMenu
      };
    },
    menuStyle() {
      return {
        display: this.showMenu ? "block" : "none"
      };
    },
    nonSelectOptions() {
      return this.options.filter((e) => this.selectedOptions.findIndex((t) => t.value === e.value) === -1);
    },
    filteredOptions() {
      return this.searchText ? this.nonSelectOptions.filter((e) => {
        try {
          return this.cleanSearch ? this.filterPredicate(this.accentsTidy(e.text), this.searchText) : this.filterPredicate(e.text, this.searchText);
        } catch {
          return true;
        }
      }) : this.nonSelectOptions;
    }
  },
  methods: {
    deleteTextOrLastItem() {
      !this.searchText && this.selectedOptions.length > 0 && this.deleteItem(this.selectedOptions[this.selectedOptions.length - 1]);
    },
    openOptions() {
      l.openOptions(this);
    },
    blurInput() {
      l.blurInput(this);
    },
    closeOptions() {
      l.closeOptions(this);
    },
    prevItem() {
      l.prevItem(this), this.openOptions();
    },
    nextItem() {
      l.nextItem(this), this.openOptions();
    },
    enterItem() {
      l.enterItem(this);
    },
    pointerSet(e) {
      l.pointerSet(this, e);
    },
    pointerAdjust() {
      l.pointerAdjust(this);
    },
    mousedownItem() {
      l.mousedownItem(this);
    },
    selectItem(e) {
      const t = this.selectedOptions.concat(e), n = t.filter((d, r) => t.indexOf(d) === r);
      this.closeOptions(), this.searchText = "", this.$emit("select", n, e, "insert");
    },
    deleteItem(e) {
      const t = this.selectedOptions.filter((n) => n.value !== e.value);
      this.$emit("select", t, e, "delete");
    },
    accentsTidy(e) {
      let t = e.toString().toLowerCase();
      return t = t.replace(new RegExp("[\xE0\xE1\xE2\xE3\xE4\xE5]", "g"), "a"), t = t.replace(new RegExp("\xE6", "g"), "ae"), t = t.replace(new RegExp("\xE7", "g"), "c"), t = t.replace(new RegExp("[\xE8\xE9\xEA\xEB]", "g"), "e"), t = t.replace(new RegExp("[\xEC\xED\xEE\xEF]", "g"), "i"), t = t.replace(new RegExp("\xF1", "g"), "n"), t = t.replace(new RegExp("[\xF2\xF3\xF4\xF5\xF6]", "g"), "o"), t = t.replace(new RegExp("\u0153", "g"), "oe"), t = t.replace(new RegExp("[\xF9\xFA\xFB\xFC]", "g"), "u"), t = t.replace(new RegExp("[\xFD\xFF]", "g"), "y"), t;
    }
  }
};
var P = createBaseVNode("i", { class: "dropdown icon" }, null, -1);
var L = ["data-vss-custom-attr"];
var H = ["onClick"];
var K = ["disabled", "tabindex", "id", "name"];
var N = ["data-vss-custom-attr", "onClick", "onMouseenter"];
function z(e, t, n, d, r, s) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(["ui fluid search dropdown selection multiple", { "active visible": r.showMenu, error: e.isError, disabled: e.isDisabled }]),
    onClick: t[11] || (t[11] = (...i) => s.openOptions && s.openOptions(...i)),
    onFocus: t[12] || (t[12] = (...i) => s.openOptions && s.openOptions(...i))
  }, [
    P,
    n.hideSelectedOptions ? createCommentVNode("", true) : (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(n.selectedOptions, (i, o) => (openBlock(), createElementBlock("a", {
      key: o,
      class: "ui label transition visible",
      style: { display: "inline-block !important" },
      "data-vss-custom-attr": n.customAttr(i)
    }, [
      createTextVNode(toDisplayString(i.text), 1),
      createBaseVNode("i", {
        class: "delete icon",
        onClick: (h2) => s.deleteItem(i)
      }, null, 8, H)
    ], 8, L))), 128)),
    withDirectives(createBaseVNode("input", {
      class: "search",
      autocomplete: "off",
      disabled: e.isDisabled,
      tabindex: e.isDisabled ? -1 : 0,
      id: e.id,
      name: e.name,
      "onUpdate:modelValue": t[0] || (t[0] = (i) => r.searchText = i),
      ref: "input",
      style: normalizeStyle(s.inputWidth),
      onFocus: t[1] || (t[1] = withModifiers((...i) => s.openOptions && s.openOptions(...i), ["prevent"])),
      onKeyup: [
        t[2] || (t[2] = withKeys((...i) => s.closeOptions && s.closeOptions(...i), ["esc"])),
        t[7] || (t[7] = withKeys(withModifiers((...i) => s.enterItem && s.enterItem(...i), ["prevent"]), ["enter"]))
      ],
      onBlur: t[3] || (t[3] = (...i) => s.blurInput && s.blurInput(...i)),
      onKeydown: [
        t[4] || (t[4] = withKeys((...i) => s.prevItem && s.prevItem(...i), ["up"])),
        t[5] || (t[5] = withKeys((...i) => s.nextItem && s.nextItem(...i), ["down"])),
        t[6] || (t[6] = withKeys(withModifiers(() => {
        }, ["prevent"]), ["enter"])),
        t[8] || (t[8] = withKeys((...i) => s.deleteTextOrLastItem && s.deleteTextOrLastItem(...i), ["delete"]))
      ]
    }, null, 44, K), [
      [vModelText, r.searchText]
    ]),
    createBaseVNode("div", {
      class: normalizeClass(["text", s.textClass])
    }, toDisplayString(s.inputText), 3),
    createBaseVNode("div", {
      class: normalizeClass(["menu", s.menuClass]),
      ref: "menu",
      onMousedown: t[10] || (t[10] = withModifiers(() => {
      }, ["prevent"])),
      style: normalizeStyle(s.menuStyle),
      tabindex: "-1"
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(s.filteredOptions, (i, o) => (openBlock(), createElementBlock("div", {
        key: o,
        class: normalizeClass(["item", { selected: i.selected || r.pointer === o, disabled: i.disabled }]),
        "data-vss-custom-attr": n.customAttr(i),
        onClick: withModifiers((h2) => s.selectItem(i), ["stop"]),
        onMousedown: t[9] || (t[9] = (...h2) => s.mousedownItem && s.mousedownItem(...h2)),
        onMouseenter: (h2) => s.pointerSet(o)
      }, toDisplayString(i.text), 43, N))), 128))
    ], 38)
  ], 34);
}
var g = w(B, [["render", z]]);
var q = {
  name: "MultiListSelect",
  mixins: [b],
  emits: ["blur", "searchchange", "select"],
  render: function() {
    return h(g, {
      id: this.id,
      name: this.name,
      options: this.options,
      selectedOptions: this.items,
      isError: this.isError,
      isDisabled: this.isDisabled,
      placeholder: this.placeholder,
      filterPredicate: this.filterPredicate,
      onSelect: this.onSelect,
      onSearchchange: (e) => this.$emit("searchchange", e)
    });
  },
  props: {
    list: {
      type: Array
    },
    optionValue: {
      type: String
    },
    optionText: {
      type: String
    },
    customText: {
      type: Function
    },
    selectedItems: {
      type: Array
    },
    optionDisabled: {
      type: String
    }
  },
  computed: {
    options() {
      return this.list.map((e) => ({ value: e[this.optionValue], text: this.buildText(e), disabled: !!e[this.optionDisabled] }));
    },
    items() {
      return this.selectedItems.map((e) => ({ value: e[this.optionValue], text: this.buildText(e), disabled: !!e[this.optionDisabled] }));
    }
  },
  methods: {
    buildText(e) {
      return e[this.optionValue] !== void 0 ? this.customText ? this.customText(e) : e[this.optionText] : "";
    },
    onSelect(e, t) {
      if (Object.keys(t).length === 0 && t.constructor === Object)
        this.$emit("select", e, t);
      else {
        const n = this.list.filter((r, s) => e.find((i, o) => r[this.optionValue] === i.value)), d = this.list.find((r) => r[this.optionValue] === t.value);
        this.$emit("select", n, d);
      }
    }
  },
  components: {
    MultiSelect: g
  }
};
export {
  W as ModelListSelect,
  y as ModelSelect,
  q as MultiListSelect,
  g as MultiSelect
};
//# sourceMappingURL=vue-search-select.js.map
